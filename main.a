; ACME 0.96.4
; 
; [binary MAX Size: $D000-$FBFF = (16+16+12)*256 = 11264 bytes]
;
; DIGIDREAM 2 aka SID VOICE EDITION
; [FRENCH TOUCH]
; GROUiK
; 04/2024
;
; v0.05 - Intro Effect added / various improvements / timeline added
; v0.04 - Other DGR Effects added / Credits page displayed
; v0.03 - DGR Effect added (some tests for now) / DGR "intro" screen (WIP)
; v0.02 - DGR window "enough stable" added / some bugs fixed / some comments added/corrected
; v0.01 - first commit (files mainly from first tests)
;
!cpu 6502
!convtab "a2txt.bin" ; 
!sl "lbl_main.txt"

; include
!source "floadc_lbl.a"
!source "effect_lbl.a"

                *= $D000 ; ORG = $D000 (RAM Langage Card)

; =============================================================================
; SYSTEM/CONSTANT
VERTBLANK       = $C019 ;
; =============================================================================
; ZERO PAGE individual

; decompLZ4
src1        	= $30   	; +$31
src2        	= $32   	; +$33
dest        	= $34   	; +$35
lenL        	= $36
lenH        	= $37
token       	= $38


; USED by PLAYER PYM + INT
; ------------------------
saveA       	= $4B
saveY       	= $4C
saveX       	= $4D
Tick        	= $4E   ; +$4F

nREG0	        = $50
vREG0	        = $51
dREG0	        = $52	; +$53
nREG1	        = $54
vREG1	        = $55
dREG1	        = $56	; +$57
nREG2	        = $58
vREG2	        = $59
dREG2	        = $5A	; +$5B
nREG3	        = $5C
vREG3	        = $5D
dREG3	        = $5E	; +$5F
nREG4	        = $60
vREG4	        = $61 
dREG4	        = $62	; +$63
nREG5	        = $64
vREG5	        = $65 
dREG5	        = $66	; +$67
nREG6	        = $68
vREG6	        = $69
dREG6	        = $6A	; +$6B
nREG7	        = $6C
vREG7	        = $6D
dREG7	        = $6E	; +$6F
nREG8	        = $70
dREG8	        = $71	; +$72
nREG9	        = $73
dREG9	        = $74	; +$75
nREGA	        = $76
dREGA		    = $77	; +$78
nREGB		    = $79
vREGB		    = $7A 
dREGB		    = $7B	; +$7C
nREGC		    = $7D
vREGC		    = $7E 
dREGC		    = $7F	; +$80
nREGD		    = $81
vREGD		    = $82
dREGD		    = $83	; +$84
; 3 next variables must follow each other (not really needed for this prod)
vREG8           = $85
vREG9           = $86
vREGA           = $87

count1Pat   	= $88
indexPat    	= $89

iREG0       	= $8A
iREG1       	= $8B
iREG2       	= $8C
iREG3       	= $8D
iREG4       	= $8E
iREG5       	= $8F
iREG6       	= $90
iREG7       	= $91
iREG8       	= $92
iREG9       	= $93
iREGA       	= $94
iREGB       	= $95
iREGC       	= $96
iREGD       	= $97

nREGE		    = $98
vREGE		    = $99
dREGE		    = $9A	; +$9B
nREGF		    = $9C
vREGF		    = $9D
dREGF		    = $9E	; +$9F
iREGE       	= $A0
iREGF       	= $A1

; SID-VOICES specific       
valV            = $A2
intL            = $A3
intH            = $A4
sidOff          = $A5                       ; toggle for activate SID-VOICES effect
bSIDA           = $A6                       
bSidOff         = $A7                       ; bolean if SID-VOICES on this tick!
valEOR          = $A8

; effects
indexTEX		= $A9                       ; TODO: group variables not used at the same time
count		    = $AA
indexLAYER1	    = $AB
countLAYER1	    = $AC
indexLAYER2	    = $AD
countLAYER2	    = $AE
indexIntro      = $AF
saveIntro       = $B0
countIntro      = $B1

; track timing
indexTTrack     = $B2

; WARNING: do not reach $CC
; =================================================================================================
MAIN
!zone
                STA $C000           		        ; 80STOREOFF
                STA $C008           		        ; zero Page = Main (+ $FXXX MAIN)

                ; Music Loading ($1000 Main)
                LDA #$02
                STA TRACK_TO_REACH         		
		        LDA #00
		        STA BUFFER
		        STA FIRSTSEC 
                LDA #$10            		
                STA BUFFER+1        
                LDA #95                     
                STA COUNT_TOTAL     
                JSR FLOAD         		

                ; decomp MUSIC (-> $1000 Aux)
                STA $C005                           ; RAMWRTON: write AUX memory from $200-$BFFF
                                                    ; read MAIN
                LDA #<($1000+11)    		        ; (+11 => skip LZ4 header)
                STA src2
                LDA #>($1000+11)
                STA src2+1
                LDA #<($1000)
                STA dest            
                LDA #>($1000)
                STA dest+1
                JSR DECOMPLZ4

                STA $C004                           ; WRITE MAIN

                ; gfx hgr loading to PAGE1
                LDA #$05
                STA TRACK_TO_REACH         		
		        LDA #00
		        STA BUFFER
		        STA FIRSTSEC 
                LDA #$20            		
                STA BUFFER+1        
                LDA #64                     
                STA COUNT_TOTAL     
                JSR FLOAD

                ; load screen DLORES
		        LDA #$07
            	STA TRACK_TO_REACH         		
		        LDA #00
		        STA BUFFER
		        STA FIRSTSEC 
            	LDA #$08            		
            	STA BUFFER+1        
            	LDA #8
            	STA COUNT_TOTAL     
            	JSR FLOAD

		        STA $C005 		                    ; write AUX           		
		        LDA #00
		        STA BUFFER
		        LDA #16
		        STA FIRSTSEC 
            	LDA #$08            		
            	STA BUFFER+1        
            	LDA #08
            	STA COUNT_TOTAL     
            	JSR FLOAD
		        
                STA $C004 		                    ; write MAIN          
                ; effect routine loading to $6000
                LDA #$08
                STA TRACK_TO_REACH         		
		        LDA #00
		        STA BUFFER
		        STA FIRSTSEC 
                LDA #$60            		
                STA BUFFER+1        
                LDA #64                             ; TO CHECK !!!                     
                STA COUNT_TOTAL     
                JSR FLOAD


                BIT DRVOFF		                    ; stop DISK II / ALL loading finished
                
                STA $C005                           ; WRITE AUX
                ; fill PAGE1 DLORES with WHITE color
                ; AUX
                LDY #00
                LDX #$04
                LDA #$FF                        
.mod0           STA $400,Y
                INY
                BNE .mod0
                INC .mod0+2
                DEX
                BNE .mod0

                ; set mode for "INTRO" part
                BIT $C050                           ; mode GFX
                BIT $C055                           ; PAGE 2
                BIT $C056                           ; (D)GR
                STA $C00D		                    ; 80 colonnes
		        STA $C05E		                    ; RESET AN3

                STA $C004                           ; WRITE MAIN
                ; MAIN
                LDX #$04
                LDA #$FF                    
.mod2           STA $400,Y
                INY
                BNE .mod2
                INC .mod2+2
                DEX
                BNE .mod2
                ; ---------------------------------------

                STA $C003                           ; READ AUX ($200-$BFFF)
                
; =================================================================================================
Init_MB     	; init Mockingboard (SLOT#4)        
!zone
                
                ; init MB (6522/AY1)
            	LDA #$FF
           	    STA AY_ADDR+3    	
            	LDA #$07
            	STA AY_ADDR+2        
            	; ---------
            	; clean REGISTERS AY1
            	LDA #$00
            	STA AY_ADDR
            	LDA #$04
            	STA AY_ADDR
            	; ---------
            	LDA #PATTERNSIZE
            	STA count1Pat
                LDA #02
		        STA countLAYER1
                LDA #01
                STA bSidOff                         ; =1 for initial INT
            	LDA #00
                STA countIntro
                STA saveIntro
                STA indexIntro
                STA indexTTrack
                STA indexTEX
                STA count
                STA bSIDA
            	STA Tick
            	STA Tick+1
            	STA indexPat
                STA sidOff
		        STA indexLAYER1
		        STA indexLAYER2
		        STA countLAYER2
            	TAX                 		        ; = 0 - init with pattern 0
            	JSR INIT_PATTERN                    ; init music data with initial parameters
; -------------------------------------
Init_INT    	; init interrupt
!zone       
            	; pour IIe 
            	LDA #<INT_ROUT
            	STA $FFFE       
            	LDA #>INT_ROUT
            	STA $FFFF
 
            	SEI                 		        ; inhib
            	; Set INT
            	LDA #%01000000      		        ; 
            	STA $C40B           		        ; Auxiliary Control Register 6522-1 [T1/6522-1 Continuous Interrupt (FREE MODE) / PB7 disabled / T2 One Shot Mode]
                STA $C48B
            	LDA #%11000000      		        ; 
            	STA $C40E           		        ; Interrupt Enable Register [6522-1 Enable Timer 1 INT / Timer 2 INT Disabled]
                STA $C48E                           ; Interrupt Enable Register [6522-2 Enable Timer 1 INT / Timer 2 INT Disabled]
                
                ; wait for DISPLAY
-           	LDA VERTBLANK
            	BMI -        
-           	LDA VERTBLANK
            	BPL -                       		; wait until next DISPLAY on

                ; here "beginning" of DISPLAY (no need to be more precise)
                LDY #75
                JSR WAIT65                          ; wait Y lines (first part of HGR)

                ; set 6522-2/T1 - sync code for beginning DGR window
                LDX #$36                                                        
            	LDY #$4F                            ; one full PAL frame (20280-2)                                                                  
            	STX $C484                   		; T2C_1-Lower                    
            	STY $C485                   		; T2C_1-High  (+reset interrupt flag)

                LDY #90
                JSR WAIT65                          ; wait Y lines (DGR window "height")

                ; init MAIN TIMER: PLAYER PYM (T2/6522-1)
                ; 50Hz PAL Delay : 20280-2 = 20278
                LDX #$36                                                        
            	LDY #$4F                                                                   
            	STX $C408                   		; T2C_1-Lower                    
            	STY $C409                   		; T2C_1-High  (+reset interrupt flag)                      
                
                ; set 6522-1/T1 first INTERRUPT (initial SID VOICE TIMER - value not really matter here)
                INT1_INIT_DELAY = 700               
                LDA #<INT1_INIT_DELAY
                STA $C404
                LDA #>INT1_INIT_DELAY
                STA $C405
                
                CLI  
; =================================================== 
                ; MAIN LOOP  
M_LOOP           
    		    LDA #%00100000 
LOOP        	BIT $C40D                  
            	BEQ LOOP                    		; test IFR bit5 -> T2 timer reaches 0 (T2/6522-1)              		
            	
            	; (re)fill registers for TIMER 2 (no INT here) - T2/6522-1  
                SEI                                 ; disable INT to "stabilize" DGR window
                LDA #($36-14)                       ; 14 = empirical value!
                SEC                                 ; compute new delay value (minus cycles already passed)
                ADC $C408                           ; SEC/negative value here (counter = $FFXX)
                STA $C408
                LDA #$4F
                ADC $C409         
            	STA $C409                   		; write T2C_1-High          
            
                ; set HGR window (start)            ; note: HGR disabled/DGR enabled for INTRO so following parameters:
mod80_1         STA $C00D                           ; $C00D = 80 col ON / $C00C = 80 col OFF
modAN3_1        STA $C05E                           ; $C05E = RESET AN3 / $C05F = SET AN3
modPAGE_1       BIT $C055                           ; PAGE 2 / PAGE 1
modGFX_1        BIT $C056                           ; GR / HGR (again)
                CLI                                 ; enable INT after switch to HGR again
                
                ; test keyboard to toogle SID/Channels
                LDA $C000
                BPL .next
                CMP #$A0                            ; test SPACE key to toogle sid off/on
                STA $C010
                BNE .next
                LDA sidOff
                EOR #$01
                STA sidOff

.next           
modJSR_PART     JSR EMPTY
            	
                ; play one tick
            	JSR PLAYER_PYM
            	INC Tick                    		; inc frame counter                                             
            	BNE +                                                                               
            	INC Tick+1                                                                  
+           	LDA Tick
                LDX indexTTrack                  
            	CMP TimeLineL,X
                BNE M_LOOP
            	LDA Tick+1
            	CMP TimeLineH,X                      
            	BNE M_LOOP

                ; set and prepare next Part
                ;LDX indexTTrack
                LDA TablePARTL,X
                STA modJSR_PART+1
                LDA TablePARTH,X
                STA modJSR_PART+2
                LDA TablePrepaPartL,X
                STA modJSR_PREPA+1
                LDA TablePrepaPartH,X
                STA modJSR_PREPA+2
                INC indexTTrack
modJSR_PREPA    JSR $FFFF               
                JMP M_LOOP
                
; =================================================================================================
; PARTS as subroutines
; =================================================================================================
LOOP_SONG
!zone
                LDA #PATTERNSIZE
            	STA count1Pat
            	LDX #00
                STX indexPat
            	JSR INIT_PATTERN                    ; init music data with initial parameters
                RTS
; -------------------------------------------------------------------------------------------------
INTRO           ; AUX Color [0x00,0x08,0x01,0x09,0x02,0x0A,0x03,0x0B,0x04,0x0C,0x05,0x0D,0x06,0x0E,0x07,0x0F]
!zone           ;              00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
                INC countIntro
                LDA countIntro
                CMP #5
                BNE .quit
                LDA #00
                STA countIntro
                ; restore old bar
                LDX saveIntro                       ; old BAR#
                LDY #$AA
                LDA #$55
                STA $C002                           ; READ MAIN
                JSR EFFECT_INTRO
                STA $C003                           ; READ AUX
                ; color new bar
                LDY indexIntro
                LDX TableIntro,Y
                STX saveIntro                       ; save for next restoring
                LDY #$EE
                LDA #$DD
                STA $C002                           ; READ MAIN
                JSR EFFECT_INTRO
                STA $C003                           ; READ AUX
                LDY indexIntro
                INY                                 
                CPY #10
                BNE +
                LDY #00
+               STY indexIntro
.quit           RTS
; -------------------------------------------------------------------------------------------------
EMPTY
CREDITS         ; empty
!zone
                RTS
; -------------------------------------------------------------------------------------------------
PREPA_CRED
!zone   
                LDA #$57
                STA modGFX_2+1                      ; HGR
                LDA #$54
                STA modPAGE_2+1                     ; PAGE 1
                LDA #$0C
                STA mod80_2+1                       ; 80 colonnes OFF
                LDA #$5F
                STA modAN3_2+1                      ; SET AN3
                RTS
; -------------------------------------------------------------------------------------------------
PREPA_F
!zone
                LDA #$0C
                STA mod80_1+1                       ; set $C00C = 80 col ON
                LDA #$5F
                STA modAN3_1+1                      ; set $C05F = SET AN3
                LDA #$54
                STA modPAGE_1+1                     ; set PAGE 1
                STA modPAGE_2+1       
                LDA #$57
                STA modGFX_1+1                      ; set HGR
                RTS
; -------------------------------------------------------------------------------------------------
EFF_F
!zone
                LDA count
		        EOR #01
		        STA count
		        BEQ ++
		        LDX indexTEX
		        STA $C002                           ; READ MAIN
                JSR EFFECT1
                STA $C003                           ; READ AUX 
		        INX
		        CPX #16
		        BNE +
		        LDX #00
+		        STX indexTEX                
++              RTS
; ------------------------------------------------------------------------------------------------
CHANGE_TEX
!zone           ; X = offset HIGH TEX AUX part / Y = offset HIGH TEX MAIN part 
                STX modTEXA_00+2
                STX modTEXA_01+2
                STX modTEXA_02+2
                STX modTEXA_03+2
                STX modTEXA_04+2
                STX modTEXA_05+2
                STX modTEXA_06+2
                STX modTEXA_07+2
                STX modTEXA_08+2
                STX modTEXA_09+2
                STX modTEXA_10+2
                STX modTEXA_11+2
                STX modTEXA_12+2
                STX modTEXA_13+2
                STX modTEXA_14+2
                STX modTEXA_15+2

                STY modTEXM_00+2
                STY modTEXM_01+2
                STY modTEXM_02+2
                STY modTEXM_03+2
                STY modTEXM_04+2
                STY modTEXM_05+2
                STY modTEXM_06+2
                STY modTEXM_07+2
                STY modTEXM_08+2
                STY modTEXM_09+2
                STY modTEXM_10+2
                STY modTEXM_11+2
                STY modTEXM_12+2
                STY modTEXM_13+2
                STY modTEXM_14+2
                STY modTEXM_15+2
                RTS
; -------------------------------------------------------------------------------------------------
PREPA_T
!zone           ; we just need to change high part of OFFSET (tables must be aligned)
                LDX #>TEX3A
                LDY #>TEX3M
                JSR CHANGE_TEX
                RTS
; -------------------------------------------------------------------------------------------------
EFF_T                                               ; TODO reunit EFF_F/EFF_T/PARALLAX ?
!zone
                LDA count
		        EOR #01
		        STA count
		        BEQ ++
		        LDX indexTEX
		        STA $C002                           ; READ MAIN
                JSR EFFECT1
                STA $C003                           ; READ AUX 
		        INX
		        CPX #16
		        BNE +
		        LDX #00
+		        STX indexTEX                
++              RTS
; -------------------------------------------------------------------------------------------------
PREPA_PARA
!zone           ; we just need to change high part of OFFSET (tables must be aligned)
                LDX #>TEX2A
                LDY #>TEX2M
                JSR CHANGE_TEX                
                RTS
; -------------------------------------------------------------------------------------------------
PARALLAX                                            ; TODO reunit EFF_F/EFF_T/PARALLAX ?
!zone
                LDA count
		        EOR #01
		        STA count
		        BEQ ++
		        LDX indexTEX
		        STA $C002                           ; READ MAIN
                JSR EFFECT1
                STA $C003                           ; READ AUX 
		        INX
		        CPX #16
		        BNE +
		        LDX #00
+		        STX indexTEX                
++              RTS
; ------------------------------------------------------------------------------------------------
EFF_SCROLL
!zone
		        ; fill buffer with new TEX
		        ; layer 1 (background) (30*6 steps)
		        LDY indexLAYER1
		        LDX #00
-		        LDA TEX1,Y
		        STA SCBUFFER,X
		        INY
		        INX
		        CPX #30
		        BNE -
		        CPY #(30*6)
		        BNE +
		        LDY #00
+		        DEC countLAYER1
		        BNE +
		        STY indexLAYER1
		        LDA #02
		        STA countLAYER1
+
		        ; layer 2 (20 * 10 steps)
		        LDY indexLAYER2
		        LDX #00
-		        LDA SCBUFFER,X
		        AND MTEX2,Y
		        ORA TEX2,Y
		        STA SCBUFFER,X
		        INY
		        INX
		        CPX #20
		        BNE -
		        CPY #(20*10)
		        BNE +
		        LDY #00
+		        STY indexLAYER2

		        STA $C002                           ; READ MAIN
                JSR EFFECT2
                STA $C003                           ; READ AUX 

+		        RTS
; =================================================================================================
INT_ROUT 
!zone                    
                STA saveA      
            	STX saveX     
            	STY saveY

                ; check if 6522-1/T1 INT (sid voice)
        	    BIT $C40D                           ; bit6 IFR -> V - if set, Timer1 = 0 so int occured      
                BVS .int_sid   
                
                ; else 6522-2/T1
.int_sync       
                ; set DGR windows (start)
modGFX_2        BIT $C056                           ; (D)GR
modPAGE_2       BIT $C055                           ; PAGE 2/1
mod80_2         STA $C00D		                    ; 80 colonnes
modAN3_2		STA $C05E		                    ; RESET AN3
                
                BIT $C484                           ; reset IFR (6522-2)
                LDA saveA
            	LDX saveX
            	LDY saveY
                RTI

.int_sid        ; 6522-1/T1 INT occured / SID VOICE effect
                LDA bSidOff
                BNE ++

                LDA sidOff
                BNE +

		        LDA #08                            	; register# volume SID VOICE (08 here)
		        STA AY_ADDR+1		                ; reg#				
		        LDA #$07			                ; Set fct "Set PSG Reg #"
		        STA AY_ADDR		                    ; ORB1 (fct)
		        LDX #$04			                ; Set fct "Inactive"
		        STX AY_ADDR		                    ; ORB1 (fct)

		        LDA valV			                ; reg value
		        STA AY_ADDR+1		                ; ORA1 (data)
		        LDA #$06			                ; Set fct "Write DATA"
		        STA AY_ADDR		                    ; ORB1 (fct) 
		        STX AY_ADDR		                    ; Set fct "Inactive" / ORB1 (fct)

+            	LDA valV
            	EOR valEOR                          ; 0 <-> vol SID VOICE
            	STA valV

++            	BIT $C404           		        ; IFR b6 cleared by read T1C_1-Lower (T1/6522-1)
                LDA saveA
            	LDX saveX
            	LDY saveY

mod_RTI         RTI                                 ; RTI/NOP ($40/$EA)

                ; SET SID VOICE INT
                ; ------------------
                ; set new TIMER delay (T1/6522-1) for SID-VOICES	
.setsidInt      LDX intL
                LDY intH
                STX $C404      	                 	; T1C_1-Lower       	
        		STY $C405                        	; T1C_1-High   => countdown from now! / IFR b6 cleared
                STX mod_comp_intL+1                 ; save last INT delay value for next comp
                STY mod_comp_intH+1

                LDA #$40                            ; restore RTI opcode
                STA mod_RTI

                LDA vREG8                           ; set new value for valV and valEOR from sid_voice vol
                STA valEOR
                STA valV

                LDA saveA
            	LDX saveX
            	LDY saveY 
                RTI
; =================================================================================================
PLAYER_PYM
!zone		    
                LDA #00
                STA bSIDA                           ; reset for each frame

                SEI                                 ; inib INT while changing AY REGISTERS
                ; -------------------------------------
                ; "REGISTER" F       		        ; containing high INT delay value
        		LDY vREGF                           
                BMI .noSid                          ; if bit 7 = 1, SID VOICE off this frame (no need to load intL)                       

                ; "REGISTER" E       		        ; containing low INT delay value
        		LDX vREGE    
mod_comp_intL   CPX #00                             ; compare to last int delay (Low)
                BNE .setnextInt                     ; not the same ? So set INT
                
mod_comp_intH   CPY #00                             ; compare to last int delay (High)
                BEQ .noNewInt                       ; same ? Ok check valV
                
                ; set new int after next INT
.setnextInt     LDA #$EA                            ; NOP
                STA mod_RTI                         ; will replace RTI to setup next int               
                STY intH                            ; save INT param L/H
                STX intL
                LDY #00
                BEQ +                               ; always

.noNewInt       ; keep same INT so we check only valV value / set valEOR value / and mute normal volume!
                LDA vREG8
                STA valEOR
                LDY #00
                LDA valV
                BEQ +                               ; if = 0 keep going
                LDA vREG8                           ; else set new volume (for XOR in INT_ROUT)
                STA valV                            
+               INC bSIDA                           ; set = skip "normal" set volume for concerned SID channel THIS frame 
                ; ------------------                
.noSid          STY bSidOff                         ; !=0 if no sid or 0 if sid voice this frame
                ; -------------------------------------

                ; REGISTER 0
		        LDA #00                             ; reg = 0
		        STA AY_ADDR+1		                ; reg#				
		        LDA #$07			                ; Set fct "Set PSG Reg #"
		        STA AY_ADDR		                    ; ORB1 (fct)
		        LDX #$04			                ; Set fct "Inactive"
		        STX AY_ADDR		                    ; ORB1 (fct)

		        LDA vREG0			                ; reg value
		        STA AY_ADDR+1		                ; ORA1 (data)
		        LDY #$06			                ; Set fct "Write DATA"
		        STY AY_ADDR		                    ; ORB1 (fct)
		        STX AY_ADDR		                    ; Set fct "Inactive" / ORB1 (fct)
        
		        ; REGISTER 1
        		LDA #$01
		        STA AY_ADDR+1
		        LDA #$07	                        
		        STA AY_ADDR
		        STX AY_ADDR		                    

		        LDA vREG1	
		        STA AY_ADDR+1
		        STY AY_ADDR
		        STX AY_ADDR
		
		        ; REGISTER 2
        		LDA #$02
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG2	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR
		
         		; REGISTER 3
        		LDA #$03
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG3	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR

        		; REGISTER 4
        		LDA #$04
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG4	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR

         		; REGISTER 5
        		LDA #$05
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG5	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR
		
        		; REGISTER 6
        		LDA #$06
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG6	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR	
		
        		; REGISTER 7
        		LDA #$07
		        STA AY_ADDR+1
		        ;LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREG7	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR

        		; REGISTER 8
                LDA bSIDA                   ; skip if this voice is used for SID_VOICES
                BNE ++
        		LDA #$08
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

                LDA vREG8	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR
++      
         		; REGISTER 9
                LDA #$09
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

                LDA vREG9	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR 

                ; REGISTER 10
        		LDA #$0A
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREGA	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR

        		; REGISTER 11
        		LDA #$0B
		        STA AY_ADDR+1
		        LDA #$07	
		        STA AY_ADDR
		        STX AY_ADDR

		        LDA vREGB	
		        STA AY_ADDR+1	
		        STY AY_ADDR
		        STX AY_ADDR

        		; REGISTER 12       		; 0 for all values

         		; REGISTER 13	            ; skip if = $FF
		        LDA vREGD
		        BMI +
		        TAY			                ; save value for later
		        LDA #$0D				
		        STA AY_ADDR+1        		; reg#				
		        LDA #$07			        ; Set fct "Set PSG Reg #"
		        STA AY_ADDR		            ; ORB1 (fct)			 
		        STX AY_ADDR		            ; Set fct "Inactive" / ORB1 (fct)

		        TYA			                ; restore value to write
		        STA AY_ADDR+1        		; ORA1 (data)
		        LDA #$06			        ; Set fct "Write DATA"
		        STA AY_ADDR		            ; ORB1 (fct)
		        STX AY_ADDR        		    ; Set fct "Inactive" / ORB1 (fct)
+               
                CLI                         ; allow INT again!

                ; get value registers for next frame 
                DEC nREG0
		        BNE .r1
        		LDY iREG0
        		LDA (dREG0),Y
		        STA nREG0
		        INY
		        LDA (dREG0),Y
		        STA vREG0
		        INY
        		STY iREG0

.r1             DEC nREG1
		        BNE .r2
        		LDY iREG1
        		LDA (dREG1),Y
		        STA nREG1
		        INY
		        LDA (dREG1),Y
		        STA vREG1
		        INY
        		STY iREG1

.r2             DEC nREG2
		        BNE .r3
        		LDY iREG2
        		LDA (dREG2),Y
		        STA nREG2
		        INY
		        LDA (dREG2),Y
		        STA vREG2
		        INY
        		STY iREG2

.r3             DEC nREG3
		        BNE .r4
        		LDY iREG3
        		LDA (dREG3),Y
		        STA nREG3
		        INY
		        LDA (dREG3),Y
		        STA vREG3
		        INY
        		STY iREG3

.r4             DEC nREG4
		        BNE .r5
        		LDY iREG4
        		LDA (dREG4),Y
		        STA nREG4
		        INY
		        LDA (dREG4),Y
		        STA vREG4
		        INY
        		STY iREG4

.r5             DEC nREG5
		        BNE .r6
        		LDY iREG5
        		LDA (dREG5),Y
		        STA nREG5
		        INY
		        LDA (dREG5),Y
		        STA vREG5
		        INY
        		STY iREG5

.r6             DEC nREG6
		        BNE .r7
        		LDY iREG6
        		LDA (dREG6),Y
		        STA nREG6
		        INY
		        LDA (dREG6),Y
		        STA vREG6
		        INY
        		STY iREG6

.r7             DEC nREG7
		        BNE .r8
        		LDY iREG7
        		LDA (dREG7),Y
		        STA nREG7
		        INY
		        LDA (dREG7),Y
		        STA vREG7
		        INY
        		STY iREG7

.r8             DEC nREG8
		        BNE .r9
        		LDY iREG8
        		LDA (dREG8),Y
		        STA nREG8
		        INY
		        LDA (dREG8),Y
		        STA vREG8
		        INY
        		STY iREG8
                
.r9             DEC nREG9
		        BNE .ra
        		LDY iREG9
        		LDA (dREG9),Y
		        STA nREG9
		        INY
		        LDA (dREG9),Y
		        STA vREG9
		        INY
        		STY iREG9
                
.ra             DEC nREGA
		        BNE .rb
        		LDY iREGA
        		LDA (dREGA),Y
		        STA nREGA
		        INY
		        LDA (dREGA),Y
		        STA vREGA
		        INY
        		STY iREGA

.rb             DEC nREGB
		        BNE .rd
        		LDY iREGB
        		LDA (dREGB),Y
		        STA nREGB
		        INY
		        LDA (dREGB),Y
		        STA vREGB
		        INY
        		STY iREGB
.rc
.rd   		    DEC nREGD
		        BNE .re
        		LDY iREGD
        		LDA (dREGD),Y
		        STA nREGD
		        INY
		        LDA (dREGD),Y
		        STA vREGD
		        INY
        		STY iREGD

.re             DEC nREGE
		        BNE .rf
        		LDY iREGE
        		LDA (dREGE),Y
		        STA nREGE
		        INY
		        LDA (dREGE),Y
		        STA vREGE
		        INY
        		STY iREGE

.rf             DEC nREGF
		        BNE .checkpattern
        		LDY iREGF
        		LDA (dREGF),Y
		        STA nREGF
		        INY
		        LDA (dREGF),Y
		        STA vREGF
		        INY
        		STY iREGF

.checkpattern   DEC count1Pat       		        ; end of ONE pattern ?
        		BEQ +               		        ; if yes, next pattern!
        		RTS
+       		; next pattern
        		LDA #PATTERNSIZE
        		STA count1Pat
        		INC indexPat
        		LDX indexPat

INIT_PATTERN
        		; init new pattern
        		LDA D_REG0,X
        		STA dREG0
        		LDA D_REG0+NBPATTERNS,X
        		STA dREG0+1
        		LDY #00
        		LDA (dREG0),Y
		        STA nREG0
		        INY
		        LDA (dREG0),Y
		        STA vREG0
		        INY
        		STY iREG0
        		LDA D_REG1,X
        		STA dREG1
        		LDA D_REG1+NBPATTERNS,X
        		STA dREG1+1
        		LDY #00
        		LDA (dREG1),Y
		        STA nREG1
		        INY
		        LDA (dREG1),Y
		        STA vREG1
		        INY
        		STY iREG1
        		LDA D_REG2,X
        		STA dREG2
        		LDA D_REG2+NBPATTERNS,X
        		STA dREG2+1
        		LDY #00
        		LDA (dREG2),Y
		        STA nREG2
		        INY
		        LDA (dREG2),Y
		        STA vREG2
		        INY
        		STY iREG2
        		LDA D_REG3,X
        		STA dREG3
        		LDA D_REG3+NBPATTERNS,X
        		STA dREG3+1
        		LDY #00
        		LDA (dREG3),Y
		        STA nREG3
		        INY
		        LDA (dREG3),Y
		        STA vREG3
		        INY
        		STY iREG3
        		LDA D_REG4,X
        		STA dREG4
        		LDA D_REG4+NBPATTERNS,X
        		STA dREG4+1
        		LDY #00
        		LDA (dREG4),Y
		        STA nREG4
		        INY
		        LDA (dREG4),Y
		        STA vREG4
		        INY
        		STY iREG4
        		LDA D_REG5,X
        		STA dREG5
        		LDA D_REG5+NBPATTERNS,X
        		STA dREG5+1
        		LDY #00
        		LDA (dREG5),Y
		        STA nREG5
		        INY
		        LDA (dREG5),Y
		        STA vREG5
		        INY
        		STY iREG5
        		LDA D_REG6,X
        		STA dREG6
        		LDA D_REG6+NBPATTERNS,X
        		STA dREG6+1
        		LDY #00
        		LDA (dREG6),Y
		        STA nREG6
		        INY
		        LDA (dREG6),Y
		        STA vREG6
		        INY
        		STY iREG6
        		LDA D_REG7,X
        		STA dREG7
        		LDA D_REG7+NBPATTERNS,X
        		STA dREG7+1
        		LDY #00
        		LDA (dREG7),Y
		        STA nREG7
		        INY
		        LDA (dREG7),Y
		        STA vREG7
		        INY
        		STY iREG7
        		LDA D_REG8,X
        		STA dREG8
        		LDA D_REG8+NBPATTERNS,X
        		STA dREG8+1
        		LDY #00
        		LDA (dREG8),Y
		        STA nREG8
	    	    INY
		        LDA (dREG8),Y
		        STA vREG8
		        INY
        		STY iREG8
        		LDA D_REG9,X
        		STA dREG9
        		LDA D_REG9+NBPATTERNS,X
        		STA dREG9+1
        		LDY #00
        		LDA (dREG9),Y
		        STA nREG9
		        INY
		        LDA (dREG9),Y
		        STA vREG9
		        INY
        		STY iREG9
        		LDA D_REGA,X
        		STA dREGA
        		LDA D_REGA+NBPATTERNS,X
        		STA dREGA+1
        		LDY #00
        		LDA (dREGA),Y
		        STA nREGA
		        INY
		        LDA (dREGA),Y
		        STA vREGA
		        INY
        		STY iREGA
        		LDA D_REGB,X
        		STA dREGB
        		LDA D_REGB+NBPATTERNS,X
        		STA dREGB+1
        		LDY #00
        		LDA (dREGB),Y
		        STA nREGB
		        INY
		        LDA (dREGB),Y
		        STA vREGB
		        INY
        		STY iREGB
        		LDA D_REGD,X
        		STA dREGD
        		LDA D_REGD+NBPATTERNS,X
        		STA dREGD+1
        		LDY #00
        		LDA (dREGD),Y
		        STA nREGD
		        INY
		        LDA (dREGD),Y
		        STA vREGD
        		INY
        		STY iREGD
        		LDA D_REGE,X
        		STA dREGE
        		LDA D_REGE+NBPATTERNS,X
        		STA dREGE+1
        		LDY #00
        		LDA (dREGE),Y
		        STA nREGE
		        INY
		        LDA (dREGE),Y
		        STA vREGE
        		INY
        		STY iREGE
        		LDA D_REGF,X
        		STA dREGF
        		LDA D_REGF+NBPATTERNS,X
        		STA dREGF+1
        		LDY #00
        		LDA (dREGF),Y
		        STA nREGF
		        INY
		        LDA (dREGF),Y
		        STA vREGF
        		INY
        		STY iREGF
        		RTS
; =============================================================================
DECOMPLZ4           ; MAIN -> AUX
!zone
; routine de décompression LZ4
; code: XXL and FOX (from Atari Scene)
; small modification: FT

; init routine
					LDY #0
					STY lenH
					STY lenL	
; -------------------------------------
; décomp LZ4 routine
; -------------------------------------
.BP
             		jsr   	.GET_BYTE                  
                  	sta    	token
               		lsr
               		lsr
               		lsr
               		lsr
                  	beq    	.read_offset                     ; there is no literal
                  	cmp    	#$0f
                  	jsr    	.getLength
                  	
.b_literals         jsr    	.GET_BYTE
                  	jsr    	.store
                  	bne    	.b_literals
                  	
.read_offset       	jsr    	.GET_BYTE
                  	tax
                  	sec
                  	eor    	#$ff
                  	adc    	dest
                  	sta    	src1
                  	txa
                  	php							
                  	jsr    	.GET_BYTE
                  	plp
                  	bne    	.not_done
                  	tax
                  	beq    	.unlz4_done
.not_done          	eor    	#$ff
                  	adc    	dest+1
                  	sta    	src1+1
                  	; c=1
		            lda    	token
                  	and    	#$0f
                  	adc    	#$03                            ; 3+1=4
                  	cmp    	#$13
                  	jsr    	.getLength

; modification: switch avant et après le LDA
modDECOMP 
.b1                 STA $C003           ; read AUX (pour la relecture des data déjà décompressées)
                    lda     (src1),Y
                    STA $C002           ; on repasse en mode par default (READ MAIN)
                    
                  	INC 	src1
                  	BNE 	.s1
                  	INC 	src1+1
.s1                 jsr    	.store
                  	bne    	.b1
                  	jmp		.BP                  

.store             	sta    	(dest),Y
                  	INC		dest
                  	BNE 	.s2
 					INC 	dest+1                 	
.s2                 dec    	lenL
                  	bne    	.unlz4_done
                  	dec    	lenH
.unlz4_done        	rts

.getLength_next    	jsr    	.GET_BYTE
                  	tax
                  	clc
	                adc    	lenL
                  	bcc    	.s3
                  	inc    	lenH
.s3   	            inx

.getLength         	sta    	lenL
                  	beq    	.getLength_next
                  	tax
                  	beq    	.s4
                  	inc    	lenH
.s4 	            rts

		
.GET_BYTE			LDA		(src2),Y
					INC 	src2		
					BEQ 	.s5
					RTS					
.s5					INC 	src2+1			
					RTS
; =================================================================================================
!align 255,0
WAIT65              ; = attend Y * 65 cycles exactement (JSR/RTS compris -> APPEL EN 8 cycles obligatoire -> LDY #xx / JSR WAIT65)
WAIT65ZP = * + 1    ; = attend Y * 65 cycles exactement (JSR/RTS compris -> APPEL EN 9 cycles obligatoire -> LDY ZP / JSR WAIT65Z)
!zone           
		    LDA $EA     ; 3 (dummy)  -> on arrive sur NOP si JSR WAIT65Z
WAIT62      ; = attend 1*62 cycles exactement (JSR/RTS compris -> LDY #01 / JSR WAIT63)
            DEY			; 2					
		    BEQ .S1	    ; 3/2			
                  
.WL1 	    LDX #$0B				            
.WL2 	    DEX							
		    BNE .WL2	; 2 + (2+3)*10 + 2 + 2 = 56															
                      
		    NOP			; 2					
		    NOP			; 2					
		    DEY			; 2					
		    BNE .WL1	; (56+2+2+2+3)*(Y-2) + 56 + 2 + 2 + 2 + 2 = 65*Y - 2*65 + 64 = 65*Y - 66				

WAIT59      ; = attend 1*59 cycles exactement (JSR/RTS compris -> LDY #xx / JSR WAIT59)											                      
		    LDX #$08					
.WL3 	    DEX							
		    BNE .WL3	; 2 + (2+3)*7 + 2 + 2 = 41					
                							
		    NOP			; 2					
		    NOP			; 2					
		    RTS			; 6

                        ; WAIT62 = 2 + 2 + (65-66) + 41 + 2 + 2 + 6 + (8) = 62 
                        ; WAIT65 = 3 + 2 + 2 + (65*Y-66) + 41 + 2 + 2 + 6 + (8) = 65*Y
                        ; WAIT59 = 41 + 2 + 2 + 6 + (8) = 59 					

WAIT57      ; = attend 1*57 cycles exactement (JSR/RTS compris -> LDY #xx / JSR WAIT57)											         
.S1	 	    NOP         ; 2
WAIT55      ; = attend 1*55 cycles exactement (JSR/RTS compris -> LDY #xx / JSR WAIT55)	
            LDX #08					
                      
.WL4 	    DEX							
		    BNE .WL4    ; 2 + (2+3)*7 + 2 + 2 = 41					
		    RTS         ; 6
                        ; = 49

                        ; WAIT65 = 3 + 2 + 3 + 49 + (8) = 65
                        ; WAIT62 = 2 + 3 + 49 + (8) = 62
                        ; WAIT57 = 49 + (8) = 57
                        ; WAIT55 = 47 + (8) = 55   
; =================================================================================================
AY_ADDR         = $C400        ; AY1 = $C400 / AY2 = $C480 (MB SLOT#4)

PATTERNSIZE     = 64           
NBPATTERNS      = 269          
FRAMEMAX        = 17153

D_REG0 = $1000
D_REG1 = $32F8
D_REG2 = $36C8
D_REG3 = $4976
D_REG4 = $4D30
D_REG5 = $523E
D_REG6 = $566A
D_REG7 = $596E
D_REG8 = $630C
D_REG9 = $7414
D_REGA = $823A
D_REGB = $8598
D_REGD = $8B6E
D_REGE = $8DAE
D_REGF = $AF2C

; ==================================================================================================
!align 255,0

SCBUFFER 	!fill 30,$00
                          
TablePrepaPartL !byte <EMPTY,<PREPA_F,<PREPA_PARA,<PREPA_T,<EMPTY,<PREPA_CRED,<LOOP_SONG                      ; "EMPTY" is just a simple "RTS"
TablePrepaPartH !byte >EMPTY,>PREPA_F,>PREPA_PARA,>PREPA_T,>EMPTY,>PREPA_CRED,>LOOP_SONG

;                        0      1      2       3          4          5      6
TablePARTL      !byte <INTRO,<EFF_F,<EFF_T,<PARALLAX,<EFF_SCROLL,<CREDITS,<EMPTY
TablePARTH      !byte >INTRO,>EFF_F,>EFF_T,>PARALLAX,>EFF_SCROLL,>CREDITS,>EMPTY

; xs = x*50
;                 0     1     2     3    4     5         6
;               10.3  20.5  51.2  93.1 133.2 194.6
TimeLineL !byte <515,<1025,<2560,<4655,<6660,<9730,<(FRAMEMAX-1)
TimeLineH !byte >515,>1025,>2560,>4655,>6660,>9730,>(FRAMEMAX-1)

TableIntro !byte 5,8,0,2,7,1,4,6,3,7

TEX1 	!byte 0x00,0x00,0x00,0x00,0x80,0x10,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x11,0x98,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x10,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x11,0x98,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x10,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x11,0x98,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
TEX2 	!byte 0x11,0x22,0x31,0x02,0x01,0x06,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x02,0x03,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x01,0x06,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x02,0x03,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x01,0x06,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x06,0x01,0x06,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x01,0x02,0x03,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x31,0x02,0x01,0x06,0x00,0x00,0x00,0x00,0x11,0x22,0x31,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x11,0x22,0x11,0x62,0x01,0x02,0x03,0x00,0x00,0x00,0x00,0x22,0x11,0x62,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x22
MTEX2	!byte 0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00

ENDMAIN